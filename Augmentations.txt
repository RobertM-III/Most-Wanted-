# Se necesitan estos 2 modulos y posteriormente supongo que tambien el OS
import albumentations as A
import cv2

# Se define la transformacion con muchas funciones y cada una con sus respectivos parametros, si es que
# algo falla o si las imagenes quedan muy feas ahi cambiamos los parametros y las probabilidades

transformacion = A.Compose([
    A.RandomSnow(snow_point_lower=0.3, snow_point_upper=0.7, brightness_coeff=1, always_apply=False, p=0.3), # Agrega nieve
    A.Blur(blur_limit=7, always_apply=False, p=0.3), # Difuminacion
    A.Downscale(scale_min=0.7, scale_max=1.3, interpolation=0, always_apply=False, p=0.3), # Le baja la calidad a la imagen
    A.Flip(p=0.3), # La gira horizonal, vertical o ambas. Si es que nos complica lo de las coordenadas de la bounding box entonces ahi elimiamos esta funcion
    A.GaussNoise(var_limit=(25.0, 35.0), mean=0, per_channel=True, always_apply=False, p=0.3), # Aplica ruido gaussiano, que es como para hacer unos puntitos que dajan mas borrosa la imagen
    A.ColorJitter(brightness=[0.7,1.3], contrast=[0.7,1.3], saturation=[0.7,1.3], hue=0.2, always_apply=False, p=0.3), # Cambia brillo, contraste, saturacion y el tono
    A.RandomFog(fog_coef_lower=0.3, fog_coef_upper=0.3, alpha_coef=0.08, always_apply=False, p=0.3), # Agrega neblina
    A.RandomShadow(shadow_roi=(0, 0, 1, 1), num_shadows_lower=1, num_shadows_upper=2, shadow_dimension=5, always_apply=False, p=0.3), # Agrega sombra
    A.RandomToneCurve(scale=0.1, always_apply=False, p=0.3), # Cambia la razon entre las partes mas clara y mas oscuras de la imagen
    A.ToGray(p=0.2), # Cambia la imagen a escala de grises bajo ciertas condiciones
    A.ToSepia(always_apply=False, p=0.2), # Agrega el filtro sepia, que es como mas blanquecino
]) 

# Aqui le aplicamos la transformacion

for # cada imagen que queremos editar (completar) ;
    imagen = cv2.imread(#"/path/to/image.jpg (completar)") # Cargamos la imagen y la guardamos en una variable
    imagen = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # La cambiamos de BGR a RGB (es necesario)
    transformada = transformacion(image=imagen) # Le aplicamos la transformacion a la imagen anterior, entrega un diccionario con una unica entrada, que es la imagen
    imagen_final = transformada["image"] # Extraemos dicha imagen del diccionario
    # guadar imagen_final en carpeta (completar)

# Diego tu sabes ocupar el modulo OS para evitar caer en la sucia matraca asi que ahi podrias editar estas partes que estan incompletas y tambien
# de manera coherente con los nombres de lor archivos del collab
